#! /usr/bin/env python3
"""
Pretty print for Penrose JSON trace data using ANSI color codes.

This script is intended for use with the JSON output from the tracing-subscriber
crate when `flatten_event` is set to true:

    let tracing_builder = tracing_subscriber::fmt()
        .json() // JSON logs
        .flatten_event(true)
        .finish()
        .init();


Yes you can use a different subscriber to do this in rust but I like having raw JSON
data that I can manipulate after the fact if need be. The intended use of this script
is as a pretty printer for an existing log file that has been generated by your Penrose
config. You will need to have tracing enabled and you will need to have your logs set
up to save to a file (or, alternatively, you can pipe through p_log.py directly but this
is not recommended: if you only want pretty log output on its own then just use the built
in mechanisms from tracing-subscriber itself). Example usage is like so:

    # For analysing a snapshot of log data after the fact
    $ cat ~/.penrose.log | p_log

    # For tailing JSON logs in a more readable format while Penrose is running
    $ tail -f ~/.penrose.log | p_log

    # Assume the default log file position of ~/.penrose.log
    $ p_log


Simple regex `grep` for filtering log lines is possible as a positional argument
but for rich filtering you are highly encouraged to look at the `with_env_filter` method
in trace-subscriber which allows you to set up a reload handle in order to dynamically
alter you logging filter while Penrose is running.

  > See https://github.com/sminez/my-penrose-config for an example of how to set this up.
"""
import argparse
import json
import os
import re
import sys

LOG_FILE = os.path.expanduser("~/.penrose.log")
DEFAULT_KEYS = ["timestamp", "level", "message", "target", "span", "spans"]
PREFIX = " " * 25
INDENT = "  "

COLORS = {
    "black": "\033[30m",
    "red": "\033[31m",
    "green": "\033[32m",
    "yellow": "\033[33m",
    "blue": "\033[34m",
    "purple": "\033[35m",
    "cyan": "\033[36m",
    "white": "\033[37m",
}

LEVEL_COLORS = {
    "ERROR": "red",
    "WARN": "yellow",
    "INFO": "green",
    "DEBUG": "blue",
    "TRACE": "purple",
}

TIMESTAMP_COLOR = "black"
SPAN_COLOR = "blue"
KV_COLOR = "yellow"


def main(lift, span_rows, grep):
    grep = re.compile(grep) if grep else None

    if not sys.stdin.isatty():
        f = sys.stdin
    else:
        f = open(LOG_FILE, 'r')

    for line in f:
        if not grep or grep.findall(line):
            pretty_print_line(line, lift, span_rows)


def pretty_print_line(line, lift=True, span_rows=False):
    line = json.loads(line)
    spans = line.get("spans", [])
    indent = max(len(spans), 1)

    ts = c(line["timestamp"], TIMESTAMP_COLOR)
    lvl = line["level"]
    lvl = c(lvl.rjust(5), LEVEL_COLORS[lvl], True)

    print(f"{ts} {lvl}{INDENT * indent}{line['message']}")

    if lift:
        lift_meta(line)

    if spans:
        if span_rows:
            for s in format_spans_as_rows(spans, indent, lifted=lift):
                print(s)
        else:
            print(format_spans_as_line(spans, indent, lifted=lift))

    for s in format_kvs(line, indent):
        print(s)


def c(s, color, bold=False):
    _bold = "\033[1m"
    _nc = "\033[0m"

    code = COLORS[color]
    if bold:
        code += _bold

    return f"{code}{s}{_nc}"


def fmt_span(s, lifted):
    name = c(s["name"], SPAN_COLOR, True)
    if lifted:
        return name

    kvs = {k: v for (k, v) in s.items() if k != "name"}
    meta = c(json.dumps(kvs), SPAN_COLOR) if len(kvs) > 0 else ""
    return f"{name}{meta}"


def format_spans_as_rows(spans, indent, lifted=False):
    span_indent = INDENT * indent
    formatted = [c(f"{PREFIX}{span_indent}context: ", SPAN_COLOR)]

    if len(spans) >= 1:
        formatted[0] += fmt_span(spans[0], lifted)

    span_indent += (INDENT * 4) + " "
    for s in spans[1:]:
        formatted.append(PREFIX + span_indent + fmt_span(s, lifted))

    return formatted


def format_spans_as_line(spans, indent, lifted=False):
    formatted = c(f"{PREFIX}{INDENT * indent}context: ", SPAN_COLOR)
    return formatted + c("->", "black").join(fmt_span(s, lifted) for s in spans)


def format_kvs(line, indent):
    kv_indent = INDENT * indent
    formatted = []

    for k, v in sorted(line.items()):
        if k not in DEFAULT_KEYS:
            formatted.append(c(f"{PREFIX}{kv_indent}{k}: {v}", KV_COLOR))

    return formatted


def lift_meta(line):
    for s in line.get("spans", []):
        for (k, v) in s.items():
            if k != "name":
                line[k] = v


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        "grep",
        nargs="?",
        help="a regex pattern to filter lines with before pretty printing",
    )
    parser.add_argument(
        "--no-lift",
        action="store_true",
        required=False,
        help="keep meta-data in the spans themselves instead of lifting",
    )
    parser.add_argument(
        "--span-rows",
        action="store_true",
        required=False,
        help="show spans one per line instead of as a chain",
    )

    args = parser.parse_args()
    main(not args.no_lift, args.span_rows, args.grep)
